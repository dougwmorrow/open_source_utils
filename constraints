-- Main conversion procedure that can be called from anywhere
CREATE OR ALTER PROCEDURE [dbo].[sp_ConvertXMLToNVarchar]
    @LinkedServerName NVARCHAR(128),
    @DatabaseName NVARCHAR(128),
    @SchemaName NVARCHAR(128),
    @TableName NVARCHAR(128),
    @OutputTable NVARCHAR(128) = NULL,  -- Optional: store results in a table
    @Debug BIT = 0
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @SQL NVARCHAR(MAX);
    DECLARE @ColumnList NVARCHAR(MAX) = '';
    DECLARE @ErrorMessage NVARCHAR(4000);
    DECLARE @ErrorSeverity INT;
    DECLARE @ErrorState INT;
    
    BEGIN TRY
        -- Step 1: Get column information from linked server
        CREATE TABLE #ColumnInfo (
            COLUMN_NAME NVARCHAR(128),
            DATA_TYPE NVARCHAR(128),
            IS_XML BIT DEFAULT 0
        );
        
        -- Query the linked server's information schema
        SET @SQL = N'
        INSERT INTO #ColumnInfo (COLUMN_NAME, DATA_TYPE)
        SELECT COLUMN_NAME, DATA_TYPE
        FROM OPENQUERY(' + QUOTENAME(@LinkedServerName) + ', 
            ''SELECT COLUMN_NAME, DATA_TYPE 
             FROM ' + @DatabaseName + '.INFORMATION_SCHEMA.COLUMNS 
             WHERE TABLE_SCHEMA = ''''' + @SchemaName + ''''' 
             AND TABLE_NAME = ''''' + @TableName + ''''''')';
        
        IF @Debug = 1
            PRINT 'Getting column info: ' + @SQL;
            
        EXEC sp_executesql @SQL;
        
        -- Mark XML columns
        UPDATE #ColumnInfo 
        SET IS_XML = 1 
        WHERE DATA_TYPE = 'xml';
        
        -- Step 2: Build dynamic column list with XML conversion
        SELECT @ColumnList = @ColumnList + 
            CASE 
                WHEN IS_XML = 1 THEN 
                    'CAST(' + QUOTENAME(COLUMN_NAME) + ' AS NVARCHAR(MAX)) AS ' + QUOTENAME(COLUMN_NAME)
                ELSE 
                    QUOTENAME(COLUMN_NAME)
            END + ', '
        FROM #ColumnInfo;
        
        -- Remove trailing comma
        SET @ColumnList = LEFT(@ColumnList, LEN(@ColumnList) - 1);
        
        IF @Debug = 1
        BEGIN
            PRINT 'Column list generated: ' + @ColumnList;
            SELECT * FROM #ColumnInfo;
        END
        
        -- Step 3: Execute the query with converted columns
        IF @OutputTable IS NOT NULL
        BEGIN
            -- Drop temp table if exists
            SET @SQL = 'IF OBJECT_ID(''' + @OutputTable + ''', ''U'') IS NOT NULL DROP TABLE ' + @OutputTable;
            EXEC sp_executesql @SQL;
            
            -- Create and populate output table
            SET @SQL = N'
            SELECT ' + @ColumnList + '
            INTO ' + @OutputTable + '
            FROM OPENQUERY(' + QUOTENAME(@LinkedServerName) + ', 
                ''SELECT ' + @ColumnList + '
                 FROM ' + @DatabaseName + '.' + @SchemaName + '.' + @TableName + ''')';
        END
        ELSE
        BEGIN
            -- Just select the data
            SET @SQL = N'
            SELECT *
            FROM OPENQUERY(' + QUOTENAME(@LinkedServerName) + ', 
                ''SELECT ' + @ColumnList + '
                 FROM ' + @DatabaseName + '.' + @SchemaName + '.' + @TableName + ''')';
        END
        
        IF @Debug = 1
            PRINT 'Final query: ' + @SQL;
            
        EXEC sp_executesql @SQL;
        
        -- Cleanup
        DROP TABLE #ColumnInfo;
        
    END TRY
    BEGIN CATCH
        -- Capture error details
        SET @ErrorMessage = ERROR_MESSAGE();
        SET @ErrorSeverity = ERROR_SEVERITY();
        SET @ErrorState = ERROR_STATE();
        
        -- Cleanup if needed
        IF OBJECT_ID('tempdb..#ColumnInfo') IS NOT NULL
            DROP TABLE #ColumnInfo;
        
        -- Log error (optional - create error log table if needed)
        IF OBJECT_ID('dbo.XMLConversionErrors', 'U') IS NOT NULL
        BEGIN
            INSERT INTO dbo.XMLConversionErrors (
                ErrorDate, LinkedServer, DatabaseName, SchemaName, TableName,
                ErrorMessage, ErrorSeverity, ErrorState
            )
            VALUES (
                GETDATE(), @LinkedServerName, @DatabaseName, @SchemaName, @TableName,
                @ErrorMessage, @ErrorSeverity, @ErrorState
            );
        END
        
        -- Re-raise the error
        RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
    END CATCH
END
GO

-- Helper procedure for single column conversion
CREATE OR ALTER PROCEDURE [dbo].[sp_ConvertSingleXMLColumn]
    @LinkedServerName NVARCHAR(128),
    @FullTablePath NVARCHAR(500),  -- Format: Database.Schema.Table
    @XMLColumnName NVARCHAR(128),
    @WhereClause NVARCHAR(MAX) = '',
    @ResultSet BIT = 1  -- 0 = Return as output parameter, 1 = Return as result set
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @SQL NVARCHAR(MAX);
    DECLARE @ConvertedXML NVARCHAR(MAX);
    
    BEGIN TRY
        IF @ResultSet = 1
        BEGIN
            -- Return as result set
            SET @SQL = N'
            SELECT CAST(' + QUOTENAME(@XMLColumnName) + ' AS NVARCHAR(MAX)) AS ConvertedXML
            FROM OPENQUERY(' + QUOTENAME(@LinkedServerName) + ', 
                ''SELECT CAST(' + @XMLColumnName + ' AS NVARCHAR(MAX)) AS ' + @XMLColumnName + '
                 FROM ' + @FullTablePath + 
                 CASE WHEN @WhereClause <> '' THEN ' WHERE ' + @WhereClause ELSE '' END + ''')';
            
            EXEC sp_executesql @SQL;
        END
        ELSE
        BEGIN
            -- Return as output parameter (for single row)
            SET @SQL = N'
            SELECT @ConvertedXML = ConvertedXML
            FROM OPENQUERY(' + QUOTENAME(@LinkedServerName) + ', 
                ''SELECT TOP 1 CAST(' + @XMLColumnName + ' AS NVARCHAR(MAX)) AS ConvertedXML
                 FROM ' + @FullTablePath + 
                 CASE WHEN @WhereClause <> '' THEN ' WHERE ' + @WhereClause ELSE '' END + ''')';
            
            EXEC sp_executesql @SQL, N'@ConvertedXML NVARCHAR(MAX) OUTPUT', @ConvertedXML OUTPUT;
            
            SELECT @ConvertedXML AS ConvertedXML;
        END
    END TRY
    BEGIN CATCH
        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        RAISERROR('Error converting XML column: %s', 16, 1, @ErrorMessage);
    END CATCH
END
GO

-- Create error logging table
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[XMLConversionErrors]') AND type in (N'U'))
BEGIN
    CREATE TABLE [dbo].[XMLConversionErrors](
        [ErrorID] [int] IDENTITY(1,1) NOT NULL,
        [ErrorDate] [datetime] NOT NULL,
        [LinkedServer] [nvarchar](128) NULL,
        [DatabaseName] [nvarchar](128) NULL,
        [SchemaName] [nvarchar](128) NULL,
        [TableName] [nvarchar](128) NULL,
        [ErrorMessage] [nvarchar](4000) NULL,
        [ErrorSeverity] [int] NULL,
        [ErrorState] [int] NULL,
        CONSTRAINT [PK_XMLConversionErrors] PRIMARY KEY CLUSTERED ([ErrorID] ASC)
    );
END
GO

-- Example usage procedure that calls the conversion procedure
CREATE OR ALTER PROCEDURE [dbo].[sp_ProcessLinkedServerData]
    @LinkedServerName NVARCHAR(128),
    @ProcessingType NVARCHAR(50)
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @TempTableName NVARCHAR(128) = '##XMLConverted_' + REPLACE(NEWID(), '-', '');
    
    BEGIN TRY
        -- Call the XML conversion procedure at any point
        EXEC [dbo].[sp_ConvertXMLToNVarchar] 
            @LinkedServerName = @LinkedServerName,
            @DatabaseName = 'YourDatabase',
            @SchemaName = 'dbo',
            @TableName = 'YourTableWithXML',
            @OutputTable = @TempTableName,
            @Debug = 0;
        
        -- Now process the converted data
        DECLARE @SQL NVARCHAR(MAX);
        SET @SQL = 'SELECT * FROM ' + @TempTableName + ' WHERE ProcessingType = @ProcessingType';
        
        EXEC sp_executesql @SQL, N'@ProcessingType NVARCHAR(50)', @ProcessingType;
        
        -- Cleanup
        SET @SQL = 'DROP TABLE ' + @TempTableName;
        EXEC sp_executesql @SQL;
        
    END TRY
    BEGIN CATCH
        -- Cleanup on error
        IF OBJECT_ID(@TempTableName) IS NOT NULL
        BEGIN
            SET @SQL = 'DROP TABLE ' + @TempTableName;
            EXEC sp_executesql @SQL;
        END
        
        -- Re-raise error
        THROW;
    END CATCH
END
GO
