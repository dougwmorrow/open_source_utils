/*
=====================================================
DATA TYPE & FORMAT ANALYSIS SCRIPT - TABLE LEVEL VERSION
=====================================================
This script analyzes tables for:
- Mismatched data types
- Implicit conversion candidates
- JSON/XML detection
- Binary data detection
- Currency patterns
- Phone number formats
- Postal/ZIP code patterns

USAGE:
- Set @AnalysisMode = 'LOCAL' for local table
- Set @AnalysisMode = 'LINKED' for linked server table
- Set @AnalysisMode = 'OPENQUERY' for direct SQL to linked server
=====================================================
*/

-- Configuration Parameters
DECLARE @AnalysisMode VARCHAR(20) = 'LOCAL'; -- Options: 'LOCAL', 'LINKED', 'OPENQUERY'

-- For LOCAL mode
DECLARE @LocalSchema NVARCHAR(128) = 'dbo';
DECLARE @LocalTable NVARCHAR(128) = 'YourTableName';

-- For LINKED mode (uses 4-part naming)
DECLARE @LinkedServer NVARCHAR(128) = NULL;
DECLARE @LinkedDatabase NVARCHAR(128) = NULL;
DECLARE @LinkedSchema NVARCHAR(128) = 'dbo';
DECLARE @LinkedTable NVARCHAR(128) = NULL;

-- For OPENQUERY mode (when sys/INFORMATION_SCHEMA not available)
DECLARE @OpenQueryServer NVARCHAR(128) = NULL;
DECLARE @OpenQueryTable NVARCHAR(500) = NULL; -- Full table name like 'database.schema.table'

-- Manual column definition (when metadata not accessible)
DECLARE @UseManualColumns BIT = 0;
DECLARE @ManualColumns TABLE (
    ColumnName NVARCHAR(128),
    DataType NVARCHAR(128)
);

-- Example manual column definition
/*
INSERT INTO @ManualColumns VALUES 
    ('CustomerID', 'varchar'),
    ('OrderDate', 'varchar'),
    ('Amount', 'varchar'),
    ('Phone', 'varchar');
*/

-- Create temporary tables for results
IF OBJECT_ID('tempdb..#DataTypeAnalysis') IS NOT NULL
    DROP TABLE #DataTypeAnalysis;

IF OBJECT_ID('tempdb..#ColumnsToAnalyze') IS NOT NULL
    DROP TABLE #ColumnsToAnalyze;

CREATE TABLE #DataTypeAnalysis (
    DatabaseName NVARCHAR(128),
    SchemaName NVARCHAR(128),
    TableName NVARCHAR(128),
    ColumnName NVARCHAR(128),
    CurrentDataType NVARCHAR(128),
    AnalysisType NVARCHAR(50),
    Finding NVARCHAR(MAX),
    SampleCount INT,
    TotalCount INT,
    PercentageMatch DECIMAL(5,2),
    SuggestedDataType NVARCHAR(128),
    SampleData NVARCHAR(MAX)
);

CREATE TABLE #ColumnsToAnalyze (
    DatabaseName NVARCHAR(128),
    SchemaName NVARCHAR(128),
    TableName NVARCHAR(128),
    ColumnName NVARCHAR(128),
    DataType NVARCHAR(128),
    MaxLength INT,
    AnalysisMode NVARCHAR(20)
);

-- Verify linked server exists if using LINKED or OPENQUERY mode
IF @AnalysisMode IN ('LINKED', 'OPENQUERY')
BEGIN
    DECLARE @ServerName NVARCHAR(128) = COALESCE(@LinkedServer, @OpenQueryServer);
    IF NOT EXISTS (SELECT * FROM sys.servers WHERE name = @ServerName)
    BEGIN
        PRINT 'ERROR: Linked server ''' + @ServerName + ''' not found in sys.servers';
        PRINT 'Available linked servers:';
        SELECT name AS LinkedServerName, product, provider, data_source 
        FROM sys.servers 
        WHERE is_linked = 1
        ORDER BY name;
        RETURN;
    END
END

-- Build full table name based on mode
DECLARE @FullTableName NVARCHAR(500);
DECLARE @TableIdentifier NVARCHAR(500);

IF @AnalysisMode = 'LOCAL'
BEGIN
    SET @FullTableName = QUOTENAME(@LocalSchema) + '.' + QUOTENAME(@LocalTable);
    SET @TableIdentifier = @LocalSchema + '.' + @LocalTable;
END
ELSE IF @AnalysisMode = 'LINKED'
BEGIN
    SET @FullTableName = QUOTENAME(@LinkedServer) + '.' + QUOTENAME(@LinkedDatabase) + '.' + 
                        QUOTENAME(@LinkedSchema) + '.' + QUOTENAME(@LinkedTable);
    SET @TableIdentifier = @LinkedServer + '.' + @LinkedDatabase + '.' + @LinkedSchema + '.' + @LinkedTable;
END
ELSE IF @AnalysisMode = 'OPENQUERY'
BEGIN
    SET @TableIdentifier = @OpenQueryServer + '.' + @OpenQueryTable;
END

PRINT 'Analyzing table: ' + @TableIdentifier;

-- Populate columns based on analysis mode and availability
DECLARE @SQL NVARCHAR(MAX);
DECLARE @ColumnDiscoverySuccess BIT = 0;

-- Try to get column information
IF @UseManualColumns = 1
BEGIN
    -- Use manually defined columns
    INSERT INTO #ColumnsToAnalyze
    SELECT 
        CASE WHEN @AnalysisMode = 'LOCAL' THEN DB_NAME() ELSE @LinkedDatabase END,
        CASE WHEN @AnalysisMode = 'LOCAL' THEN @LocalSchema ELSE @LinkedSchema END,
        CASE WHEN @AnalysisMode = 'LOCAL' THEN @LocalTable ELSE COALESCE(@LinkedTable, @OpenQueryTable) END,
        ColumnName,
        DataType,
        NULL AS MaxLength,
        @AnalysisMode
    FROM @ManualColumns;
    
    SET @ColumnDiscoverySuccess = 1;
END
ELSE
BEGIN
    -- Try automatic column discovery
    IF @AnalysisMode = 'LOCAL'
    BEGIN
        -- Use local sys.columns
        BEGIN TRY
            INSERT INTO #ColumnsToAnalyze
            SELECT 
                DB_NAME() AS DatabaseName,
                s.name AS SchemaName,
                t.name AS TableName,
                c.name AS ColumnName,
                TYPE_NAME(c.user_type_id) AS DataType,
                c.max_length,
                'LOCAL'
            FROM sys.columns c
            JOIN sys.tables t ON c.object_id = t.object_id
            JOIN sys.schemas s ON t.schema_id = s.schema_id
            WHERE TYPE_NAME(c.user_type_id) IN ('varchar', 'nvarchar', 'char', 'nchar', 'text', 'ntext')
                AND s.name = @LocalSchema
                AND t.name = @LocalTable;
            
            SET @ColumnDiscoverySuccess = 1;
        END TRY
        BEGIN CATCH
            PRINT 'Error discovering columns: ' + ERROR_MESSAGE();
        END CATCH
    END
    ELSE IF @AnalysisMode = 'LINKED'
    BEGIN
        -- Try INFORMATION_SCHEMA first
        BEGIN TRY
            SET @SQL = N'
            SELECT 
                ''' + @LinkedDatabase + ''' AS DatabaseName,
                TABLE_SCHEMA AS SchemaName,
                TABLE_NAME AS TableName,
                COLUMN_NAME AS ColumnName,
                DATA_TYPE AS DataType,
                CHARACTER_MAXIMUM_LENGTH AS MaxLength,
                ''LINKED'' AS AnalysisMode
            FROM ' + QUOTENAME(@LinkedServer) + '.' + QUOTENAME(@LinkedDatabase) + '.INFORMATION_SCHEMA.COLUMNS
            WHERE DATA_TYPE IN (''varchar'', ''nvarchar'', ''char'', ''nchar'', ''text'', ''ntext'')
                AND TABLE_SCHEMA = ''' + @LinkedSchema + '''
                AND TABLE_NAME = ''' + @LinkedTable + '''';
            
            INSERT INTO #ColumnsToAnalyze
            EXEC sp_executesql @SQL;
            
            SET @ColumnDiscoverySuccess = 1;
        END TRY
        BEGIN CATCH
            PRINT 'INFORMATION_SCHEMA not accessible. Error: ' + ERROR_MESSAGE();
        END CATCH
        
        -- If INFORMATION_SCHEMA failed, try sys.columns
        IF @ColumnDiscoverySuccess = 0
        BEGIN
            BEGIN TRY
                SET @SQL = N'
                SELECT 
                    ''' + @LinkedDatabase + ''' AS DatabaseName,
                    s.name AS SchemaName,
                    t.name AS TableName,
                    c.name AS ColumnName,
                    TYPE_NAME(c.user_type_id) AS DataType,
                    c.max_length,
                    ''LINKED'' AS AnalysisMode
                FROM ' + QUOTENAME(@LinkedServer) + '.' + QUOTENAME(@LinkedDatabase) + '.sys.columns c
                JOIN ' + QUOTENAME(@LinkedServer) + '.' + QUOTENAME(@LinkedDatabase) + '.sys.tables t ON c.object_id = t.object_id
                JOIN ' + QUOTENAME(@LinkedServer) + '.' + QUOTENAME(@LinkedDatabase) + '.sys.schemas s ON t.schema_id = s.schema_id
                WHERE TYPE_NAME(c.user_type_id) IN (''varchar'', ''nvarchar'', ''char'', ''nchar'', ''text'', ''ntext'')
                    AND s.name = ''' + @LinkedSchema + '''
                    AND t.name = ''' + @LinkedTable + '''';
                
                INSERT INTO #ColumnsToAnalyze
                EXEC sp_executesql @SQL;
                
                SET @ColumnDiscoverySuccess = 1;
            END TRY
            BEGIN CATCH
                PRINT 'sys.columns not accessible. Error: ' + ERROR_MESSAGE();
            END CATCH
        END
    END
    ELSE IF @AnalysisMode = 'OPENQUERY'
    BEGIN
        -- Try to get column info via OPENQUERY with a dummy query
        BEGIN TRY
            SET @SQL = N'
            SELECT TOP 0 * INTO #TempSchema 
            FROM OPENQUERY(' + QUOTENAME(@OpenQueryServer) + ', ''SELECT * FROM ' + @OpenQueryTable + ' WHERE 1=0'')
            
            INSERT INTO #ColumnsToAnalyze
            SELECT 
                ''' + @OpenQueryServer + ''' AS DatabaseName,
                ''Unknown'' AS SchemaName,
                ''' + @OpenQueryTable + ''' AS TableName,
                c.name AS ColumnName,
                TYPE_NAME(c.user_type_id) AS DataType,
                c.max_length,
                ''OPENQUERY''
            FROM tempdb.sys.columns c
            WHERE c.object_id = OBJECT_ID(''tempdb..#TempSchema'')
                AND TYPE_NAME(c.user_type_id) IN (''varchar'', ''nvarchar'', ''char'', ''nchar'', ''text'', ''ntext'')
            
            DROP TABLE #TempSchema';
            
            EXEC sp_executesql @SQL;
            SET @ColumnDiscoverySuccess = 1;
        END TRY
        BEGIN CATCH
            PRINT 'Cannot discover columns via OPENQUERY. Error: ' + ERROR_MESSAGE();
        END CATCH
    END
END

-- Check if we have columns to analyze
IF NOT EXISTS (SELECT 1 FROM #ColumnsToAnalyze)
BEGIN
    PRINT '';
    PRINT 'ERROR: No columns found to analyze.';
    PRINT 'Possible solutions:';
    PRINT '1. Set @UseManualColumns = 1 and define columns in @ManualColumns table';
    PRINT '2. Verify table name and schema are correct';
    PRINT '3. Check if the table has varchar/nvarchar columns';
    PRINT '4. Ensure you have permissions to access table metadata';
    RETURN;
END

-- Show columns to be analyzed
PRINT '';
PRINT 'Columns to analyze:';
SELECT ColumnName, DataType FROM #ColumnsToAnalyze;

-- Get total row count
DECLARE @RowCount INT = 0;
IF @AnalysisMode = 'OPENQUERY'
BEGIN
    SET @SQL = N'SELECT @Count = COUNT(*) FROM OPENQUERY(' + QUOTENAME(@OpenQueryServer) + 
               ', ''SELECT COUNT(*) AS cnt FROM ' + @OpenQueryTable + ''')';
END
ELSE
BEGIN
    SET @SQL = N'SELECT @Count = COUNT(*) FROM ' + @FullTableName;
END

BEGIN TRY
    EXEC sp_executesql @SQL, N'@Count INT OUTPUT', @Count = @RowCount OUTPUT;
    PRINT 'Total rows in table: ' + CAST(@RowCount AS VARCHAR(20));
END TRY
BEGIN CATCH
    PRINT 'Error getting row count: ' + ERROR_MESSAGE();
    SET @RowCount = -1;
END CATCH

IF @RowCount = 0
BEGIN
    PRINT 'Table is empty. No analysis performed.';
    RETURN;
END

-- Analyze each column
DECLARE @DatabaseName NVARCHAR(128);
DECLARE @SchemaName NVARCHAR(128);
DECLARE @TableName NVARCHAR(128);
DECLARE @ColumnName NVARCHAR(128);
DECLARE @DataType NVARCHAR(128);

DECLARE column_cursor CURSOR FOR
SELECT DatabaseName, SchemaName, TableName, ColumnName, DataType
FROM #ColumnsToAnalyze;

OPEN column_cursor;
FETCH NEXT FROM column_cursor INTO @DatabaseName, @SchemaName, @TableName, @ColumnName, @DataType;

WHILE @@FETCH_STATUS = 0
BEGIN
    PRINT 'Analyzing column: ' + @ColumnName;
    
    -- Build table reference based on mode
    DECLARE @TableRef NVARCHAR(500);
    IF @AnalysisMode = 'OPENQUERY'
        SET @TableRef = 'OPENQUERY(' + QUOTENAME(@OpenQueryServer) + ', ''SELECT * FROM ' + @OpenQueryTable + ''')';
    ELSE
        SET @TableRef = @FullTableName;
    
    -- 1. Check for numeric data
    BEGIN TRY
        IF @AnalysisMode = 'OPENQUERY'
        BEGIN
            -- Simplified query for OPENQUERY
            SET @SQL = N'
            INSERT INTO #DataTypeAnalysis
            SELECT 
                ''' + @DatabaseName + ''',
                ''' + @SchemaName + ''',
                ''' + @TableName + ''',
                ''' + @ColumnName + ''',
                ''' + @DataType + ''',
                ''Numeric as String'',
                ''Column contains numeric values stored as string'',
                COUNT(*) AS SampleCount,
                ' + CAST(@RowCount AS NVARCHAR(20)) + ' AS TotalCount,
                CAST(COUNT(*) * 100.0 / ' + CAST(@RowCount AS NVARCHAR(20)) + ' AS DECIMAL(5,2)) AS PercentageMatch,
                ''Check manually'' AS SuggestedDataType,
                ''See samples'' AS SampleData
            FROM OPENQUERY(' + QUOTENAME(@OpenQueryServer) + ', 
                ''SELECT ' + @ColumnName + ' FROM ' + @OpenQueryTable + ' 
                  WHERE ' + @ColumnName + ' IS NOT NULL 
                    AND ' + @ColumnName + ' REGEXP ''''^^[0-9.-]+$'''''')
            HAVING COUNT(*) > 0';
        END
        ELSE
        BEGIN
            -- Standard query for local/linked tables
            SET @SQL = N'
            INSERT INTO #DataTypeAnalysis
            SELECT 
                ''' + @DatabaseName + ''',
                ''' + @SchemaName + ''',
                ''' + @TableName + ''',
                ''' + @ColumnName + ''',
                ''' + @DataType + ''',
                ''Numeric as String'',
                ''Column contains numeric values stored as string'',
                COUNT(*),
                ' + CAST(@RowCount AS NVARCHAR(20)) + ',
                CAST(COUNT(*) * 100.0 / ' + CAST(@RowCount AS NVARCHAR(20)) + ' AS DECIMAL(5,2)),
                CASE 
                    WHEN MAX(LEN(' + QUOTENAME(@ColumnName) + ')) <= 9 THEN ''INT''
                    WHEN MAX(LEN(' + QUOTENAME(@ColumnName) + ')) <= 18 THEN ''BIGINT''
                    ELSE ''DECIMAL(18,4)''
                END,
                STUFF((SELECT TOP 5 ''; '' + CAST(' + QUOTENAME(@ColumnName) + ' AS NVARCHAR(100))
                       FROM ' + @TableRef + '
                       WHERE ' + QUOTENAME(@ColumnName) + ' IS NOT NULL
                         AND LEN(' + QUOTENAME(@ColumnName) + ') > 0
                         AND ' + QUOTENAME(@ColumnName) + ' NOT LIKE ''%[^0-9.-]%''
                       FOR XML PATH('''')), 1, 2, '''')
            FROM ' + @TableRef + '
            WHERE ' + QUOTENAME(@ColumnName) + ' IS NOT NULL
                AND LEN(' + QUOTENAME(@ColumnName) + ') > 0
                AND ' + QUOTENAME(@ColumnName) + ' NOT LIKE ''%[^0-9.-]%''
                AND ' + QUOTENAME(@ColumnName) + ' NOT LIKE ''%-%-%''
                AND ' + QUOTENAME(@ColumnName) + ' NOT LIKE ''%.%.%''
            HAVING COUNT(*) > 0';
        END
        
        EXEC sp_executesql @SQL;
    END TRY
    BEGIN CATCH
        PRINT '  - Error checking numeric patterns: ' + LEFT(ERROR_MESSAGE(), 200);
    END CATCH
    
    -- 2. Check for date patterns
    BEGIN TRY
        IF @AnalysisMode != 'OPENQUERY' -- Skip complex date checks for OPENQUERY
        BEGIN
            SET @SQL = N'
            INSERT INTO #DataTypeAnalysis
            SELECT 
                ''' + @DatabaseName + ''',
                ''' + @SchemaName + ''',
                ''' + @TableName + ''',
                ''' + @ColumnName + ''',
                ''' + @DataType + ''',
                ''Date as String'',
                ''Column contains date values stored as string'',
                COUNT(*),
                ' + CAST(@RowCount AS NVARCHAR(20)) + ',
                CAST(COUNT(*) * 100.0 / ' + CAST(@RowCount AS NVARCHAR(20)) + ' AS DECIMAL(5,2)),
                ''DATE or DATETIME'',
                STUFF((SELECT TOP 5 ''; '' + CAST(' + QUOTENAME(@ColumnName) + ' AS NVARCHAR(100))
                       FROM ' + @TableRef + '
                       WHERE ' + QUOTENAME(@ColumnName) + ' IS NOT NULL
                         AND LEN(' + QUOTENAME(@ColumnName) + ') >= 8
                         AND (' + QUOTENAME(@ColumnName) + ' LIKE ''[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]%''
                           OR ' + QUOTENAME(@ColumnName) + ' LIKE ''[0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9]%'')
                       FOR XML PATH('''')), 1, 2, '''')
            FROM ' + @TableRef + '
            WHERE ' + QUOTENAME(@ColumnName) + ' IS NOT NULL
                AND LEN(' + QUOTENAME(@ColumnName) + ') >= 8
                AND (' + QUOTENAME(@ColumnName) + ' LIKE ''[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]%''
                  OR ' + QUOTENAME(@ColumnName) + ' LIKE ''[0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9]%'')
            HAVING COUNT(*) > 0';
            
            EXEC sp_executesql @SQL;
        END
    END TRY
    BEGIN CATCH
        PRINT '  - Error checking date patterns: ' + LEFT(ERROR_MESSAGE(), 200);
    END CATCH
    
    -- 3. Check for phone patterns
    BEGIN TRY
        IF @AnalysisMode != 'OPENQUERY'
        BEGIN
            SET @SQL = N'
            INSERT INTO #DataTypeAnalysis
            SELECT 
                ''' + @DatabaseName + ''',
                ''' + @SchemaName + ''',
                ''' + @TableName + ''',
                ''' + @ColumnName + ''',
                ''' + @DataType + ''',
                ''Phone Number Pattern'',
                ''Column contains phone number patterns'',
                COUNT(*),
                ' + CAST(@RowCount AS NVARCHAR(20)) + ',
                CAST(COUNT(*) * 100.0 / ' + CAST(@RowCount AS NVARCHAR(20)) + ' AS DECIMAL(5,2)),
                ''VARCHAR(20)'',
                STUFF((SELECT TOP 5 ''; '' + CAST(' + QUOTENAME(@ColumnName) + ' AS NVARCHAR(100))
                       FROM ' + @TableRef + '
                       WHERE ' + QUOTENAME(@ColumnName) + ' IS NOT NULL
                         AND (' + QUOTENAME(@ColumnName) + ' LIKE ''[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]''
                           OR ' + QUOTENAME(@ColumnName) + ' LIKE ''([0-9][0-9][0-9]) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]''
                           OR ' + QUOTENAME(@ColumnName) + ' LIKE ''+[0-9]%'')
                       FOR XML PATH('''')), 1, 2, '''')
            FROM ' + @TableRef + '
            WHERE ' + QUOTENAME(@ColumnName) + ' IS NOT NULL
                AND (' + QUOTENAME(@ColumnName) + ' LIKE ''[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]''
                  OR ' + QUOTENAME(@ColumnName) + ' LIKE ''([0-9][0-9][0-9]) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]''
                  OR ' + QUOTENAME(@ColumnName) + ' LIKE ''+[0-9]%'')
            HAVING COUNT(*) > 0';
            
            EXEC sp_executesql @SQL;
        END
    END TRY
    BEGIN CATCH
        PRINT '  - Error checking phone patterns: ' + LEFT(ERROR_MESSAGE(), 200);
    END CATCH
    
    FETCH NEXT FROM column_cursor INTO @DatabaseName, @SchemaName, @TableName, @ColumnName, @DataType;
END

CLOSE column_cursor;
DEALLOCATE column_cursor;

-- Generate report
PRINT '';
PRINT '=====================================================';
PRINT 'DATA TYPE & FORMAT ANALYSIS RESULTS';
PRINT '=====================================================';
PRINT 'Table: ' + @TableIdentifier;
PRINT 'Mode: ' + @AnalysisMode;
PRINT '';

-- Check if any findings
IF NOT EXISTS (SELECT 1 FROM #DataTypeAnalysis)
BEGIN
    PRINT 'No data type mismatches or patterns found.';
END
ELSE
BEGIN
    -- Summary
    SELECT 
        AnalysisType,
        COUNT(DISTINCT ColumnName) AS AffectedColumns,
        MAX(PercentageMatch) AS MaxMatchPercent
    FROM #DataTypeAnalysis
    GROUP BY AnalysisType
    ORDER BY COUNT(DISTINCT ColumnName) DESC;
    
    -- Detailed findings
    PRINT '';
    PRINT 'DETAILED FINDINGS:';
    SELECT 
        ColumnName,
        CurrentDataType,
        AnalysisType,
        CAST(PercentageMatch AS VARCHAR(10)) + '%' AS MatchPercent,
        SuggestedDataType,
        LEFT(SampleData, 100) AS SampleData
    FROM #DataTypeAnalysis
    WHERE PercentageMatch >= 50
    ORDER BY PercentageMatch DESC, ColumnName;
END

-- Provide manual column template if needed
IF @ColumnDiscoverySuccess = 0
BEGIN
    PRINT '';
    PRINT '-- Column discovery failed. Use this template:';
    PRINT 'DECLARE @UseManualColumns BIT = 1;';
    PRINT 'INSERT INTO @ManualColumns VALUES';
    PRINT '    (''Column1'', ''varchar''),';
    PRINT '    (''Column2'', ''varchar''),';
    PRINT '    (''Column3'', ''varchar'');';
END

-- Clean up
DROP TABLE #DataTypeAnalysis;
DROP TABLE #ColumnsToAnalyze;
